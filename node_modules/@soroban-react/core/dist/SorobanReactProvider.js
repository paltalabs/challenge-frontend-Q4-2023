"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SorobanReactProvider = void 0;
const react_1 = __importStar(require("react"));
const SorobanClient = __importStar(require("soroban-client"));
const _1 = require("./");
function networkToActiveChain(networkDetails, chains) {
    var _a, _b;
    const supported = networkDetails &&
        chains.find((c) => c.networkPassphrase === (networkDetails === null || networkDetails === void 0 ? void 0 : networkDetails.networkPassphrase));
    const activeChain = networkDetails && {
        id: (_a = supported === null || supported === void 0 ? void 0 : supported.id) !== null && _a !== void 0 ? _a : networkDetails.networkPassphrase,
        name: (_b = supported === null || supported === void 0 ? void 0 : supported.name) !== null && _b !== void 0 ? _b : networkDetails.network,
        networkPassphrase: networkDetails.networkPassphrase,
        iconBackground: supported === null || supported === void 0 ? void 0 : supported.iconBackground,
        iconUrl: supported === null || supported === void 0 ? void 0 : supported.iconUrl,
        unsupported: !supported,
        networkUrl: networkDetails.networkUrl,
        sorobanRpcUrl: networkDetails.sorobanRpcUrl
    };
    return activeChain;
}
function fromURLToServer(sorobanRpcUrl) {
    return new SorobanClient.Server(sorobanRpcUrl, {
        allowHttp: sorobanRpcUrl.startsWith('http://'),
    });
}
function SorobanReactProvider({ appName, autoconnect = false, chains, activeChain = _1.defaultSorobanContext.activeChain, // Non mandatory fields default to default Context fields value
children, connectors, server = _1.defaultSorobanContext.server, // Non mandatory fields default to default Context fields value
 }) {
    const activeConnector = connectors.length == 1 ? connectors[0] : undefined;
    const isConnectedRef = (0, react_1.useRef)(false);
    if (activeChain === null || activeChain === void 0 ? void 0 : activeChain.sorobanRpcUrl) {
        server = fromURLToServer(activeChain.sorobanRpcUrl);
    }
    const [mySorobanContext, setSorobanContext] = react_1.default.useState(Object.assign(Object.assign({}, _1.defaultSorobanContext), { appName,
        autoconnect,
        chains,
        connectors,
        activeConnector,
        activeChain,
        server, connect: () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let networkDetails = yield ((_a = mySorobanContext.activeConnector) === null || _a === void 0 ? void 0 : _a.getNetworkDetails());
            if (!chains.find((c) => c.networkPassphrase === (networkDetails === null || networkDetails === void 0 ? void 0 : networkDetails.networkPassphrase))) {
                const error = new Error('Your Wallet network is not supported in this app');
                throw error;
            }
            let activeChain = networkToActiveChain(networkDetails, chains);
            let address = yield ((_b = mySorobanContext.activeConnector) === null || _b === void 0 ? void 0 : _b.getPublicKey());
            if (!(networkDetails === null || networkDetails === void 0 ? void 0 : networkDetails.sorobanRpcUrl)) {
                const error = new Error('Soroban RPC URL is not set, please check your freighter wallet network configuration');
                throw error;
            }
            let server = networkDetails &&
                new SorobanClient.Server(networkDetails.sorobanRpcUrl, {
                    allowHttp: networkDetails.sorobanRpcUrl.startsWith('http://'),
                });
            // Now we can track that the wallet is finally connected
            isConnectedRef.current = true;
            setSorobanContext((c) => (Object.assign(Object.assign({}, c), { activeChain,
                address,
                server })));
        }), disconnect: () => __awaiter(this, void 0, void 0, function* () {
            isConnectedRef.current = false;
            // TODO: Maybe reset address to undefined
            // TODO: Handle other things here, such as perhaps resetting address to undefined.
        }), setActiveChain: (chain) => {
            console.log("Chainging activeChain to : ", chain);
            // When the user in frontend changes the activeChain to read the blockchain without wallet
            activeChain = chain;
            if (activeChain.sorobanRpcUrl) {
                server = fromURLToServer(activeChain.sorobanRpcUrl);
            }
            setSorobanContext((c) => (Object.assign(Object.assign({}, c), { server,
                activeChain })));
        } }));
    // Handle changes of address/network in "realtime"
    react_1.default.useEffect(() => {
        let timeoutId = null;
        // If it turns out that requesting an update from Freighter is too taxing,
        // then this could be increased. Humans perceive 100ms response times as instantaneous
        // (source: https://www.pubnub.com/blog/how-fast-is-realtime-human-perception-and-technology/)
        // but you also have to consider the re-render time of components.
        const freighterCheckIntervalMs = 200;
        function checkForWalletChanges() {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                // Returns if not installed / not active / not connected (TODO: currently always isConnected=true)
                if (!mySorobanContext.activeConnector ||
                    !mySorobanContext.activeConnector.isConnected() ||
                    !isConnectedRef.current ||
                    !mySorobanContext.activeChain)
                    return;
                let hasNoticedWalletUpdate = false;
                try {
                    let chain = networkToActiveChain(yield ((_a = mySorobanContext.activeConnector) === null || _a === void 0 ? void 0 : _a.getNetworkDetails()), chains);
                    // NOTICE: If the user logs out from or uninstalls the Freighter extension while they are connected
                    // on this site, then a dialog will appear asking them to sign in again. We need a way to ask Freighter
                    // if there is _any_ connected user, without actually asking them to sign in. Unfortunately, that is not
                    // supported at this time; but it would be easy to submit a PR to the extension to add support for it.
                    let address = yield ((_b = mySorobanContext.activeConnector) === null || _b === void 0 ? void 0 : _b.getPublicKey());
                    // TODO: If you want to know when the user has disconnected, then you can set a timeout for getPublicKey.
                    // If it doesn't return in X milliseconds, you can be pretty confident that they aren't connected anymore.
                    if (mySorobanContext.address !== address) {
                        console.log('SorobanReactProvider: address changed from:', mySorobanContext.address, ' to: ', address);
                        hasNoticedWalletUpdate = true;
                        console.log('SorobanReactProvider: reconnecting');
                        mySorobanContext.connect();
                    }
                    else if (mySorobanContext.activeChain.networkPassphrase !=
                        chain.networkPassphrase) {
                        console.log('SorobanReactProvider: networkPassphrase changed from: ', mySorobanContext.activeChain.networkPassphrase, ' to: ', chain.networkPassphrase);
                        hasNoticedWalletUpdate = true;
                        console.log('SorobanReactProvider: reconnecting');
                        mySorobanContext.connect();
                    }
                }
                catch (error) {
                    // I would recommend keeping the try/catch so that any exceptions in this async function
                    // will get handled. Otherwise React could complain. I believe that eventually it may cause huge
                    // problems, but that might be a NodeJS specific approach to exceptions not handled in promises.
                    console.error('SorobanReactProvider: error: ', error);
                }
                finally {
                    if (!hasNoticedWalletUpdate)
                        timeoutId = setTimeout(checkForWalletChanges, freighterCheckIntervalMs);
                }
            });
        }
        checkForWalletChanges();
        return () => {
            if (timeoutId != null)
                clearTimeout(timeoutId);
        };
    }, [mySorobanContext]);
    react_1.default.useEffect(() => {
        if (mySorobanContext.address)
            return; // If we already have access to the connector's address, we are OK
        if (!mySorobanContext.activeConnector)
            return; // If there is not even an activeConnector, we don't need to continue
        // activeConnector.isConnected() means that the connector is installed (even if not allowed, even if locked)
        // Hence, here we want to connect automatically if autoconnect is true && if activeConnector is installed
        if (mySorobanContext.autoconnect &&
            mySorobanContext.activeConnector.isConnected()) {
            // TODO: When the page loads, autoconnect==true and the user is not signed in, this gets called twice
            // (due to the sorobanContext.activeConnector being seen as different by React), which causes
            // the Wallet window to appear twice.
            // An easy approach will be to use a ref in the connect function so that if it's already
            // trying to connect from somewhere else, then it doesn't try again
            // (since getPublicKey is what is causing the popup to appear)
            // This should be programmed in every connector for every get function
            mySorobanContext.connect();
        }
    }, [mySorobanContext.activeConnector, mySorobanContext.autoconnect]);
    return (react_1.default.createElement(_1.SorobanContext.Provider, { value: mySorobanContext }, children));
}
exports.SorobanReactProvider = SorobanReactProvider;
